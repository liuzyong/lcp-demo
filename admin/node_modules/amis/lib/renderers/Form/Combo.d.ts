/// <reference types="lodash" />
import React from 'react';
import { FormControlProps } from './Item';
import { Schema, Action, Api } from '../../types';
import { IComboStore } from '../../store/combo';
import Sortable from 'sortablejs';
export interface Condition {
    test: string;
    controls: Array<Schema>;
    label: string;
    scaffold?: any;
    mode?: string;
}
export interface ComboProps extends FormControlProps {
    placeholder?: string;
    flat?: boolean;
    draggable?: boolean;
    controls?: Array<Schema>;
    conditions?: Array<Condition>;
    multiple?: boolean;
    multiLine?: boolean;
    minLength?: number;
    maxLength?: number;
    scaffold?: any;
    addButtonClassName?: string;
    formClassName?: string;
    addButtonText?: string;
    addable?: boolean;
    typeSwitchable?: boolean;
    removable?: boolean;
    deleteApi?: Api;
    deleteConfirmText?: string;
    canAccessSuperData?: boolean;
    subFormMode?: 'normal' | 'inline' | 'horizontal';
    noBorder?: boolean;
    joinValues?: boolean;
    delimiter?: string;
    dragIcon: string;
    deleteIcon: string;
    store: IComboStore;
    tabsMode: boolean;
    tabsStyle: '' | 'line' | 'card' | 'radio';
    tabsLabelTpl?: string;
    lazyLoad?: boolean;
    changeImmediately?: boolean;
    strictMode?: boolean;
    nullable?: boolean;
    messages?: {
        validateFailed?: string;
        minLengthValidateFailed?: string;
        maxLengthValidateFailed?: string;
    };
}
export default class ComboControl extends React.Component<ComboProps> {
    static defaultProps: Pick<ComboProps, 'minLength' | 'maxLength' | 'multiple' | 'multiLine' | 'addButtonClassName' | 'formClassName' | 'subFormMode' | 'draggableTip' | 'addButtonText' | 'canAccessSuperData' | 'addIcon' | 'dragIcon' | 'deleteIcon' | 'tabsMode' | 'tabsStyle' | 'placeholder'>;
    static propsList: Array<string>;
    subForms: Array<any>;
    subFormDefaultValues: Array<{
        index: number;
        values: any;
        setted: boolean;
    }>;
    keys: Array<string>;
    dragTip?: HTMLElement;
    sortable?: Sortable;
    defaultValue?: any;
    toDispose: Array<Function>;
    id: string;
    constructor(props: ComboProps);
    componentWillMount(): void;
    componentWillReceiveProps(nextProps: ComboProps): void;
    componentWillUnmount(): void;
    getValueAsArray(props?: Readonly<ComboProps> & Readonly<{
        children?: React.ReactNode;
    }>): any;
    addItemWith(condition: Condition): void;
    addItem(): void;
    removeItem(key: number): Promise<void>;
    handleChange(values: any, diff: any, { index }: any): void;
    handleSingleFormChange(values: object): void;
    handleFormInit(values: any, { index }: any): void;
    handleSingleFormInit(values: any): void;
    handleAction(action: Action): any;
    validate(): any;
    flush(): void;
    dragTipRef(ref: any): void;
    initDragging(): void;
    destroyDragging(): void;
    refsMap: {
        [propName: number]: any;
    };
    makeFormRef: ((index: number) => (ref: any) => void) & import("lodash").MemoizedFunction;
    formRef(ref: any, index?: number): void;
    memoizedFormatValue: ((strictMode: boolean, syncFields: Array<string> | void, value: any, index: number, data: any) => object) & import("lodash").MemoizedFunction;
    formatValue(value: any, index?: number): object;
    pickCondition(value: any): Condition | null;
    handleComboTypeChange(index: number, selection: any): void;
    handleTabSelect(key: number): void;
    setNull(e: React.MouseEvent): void;
    renderPlaceholder(): JSX.Element;
    renderTabsMode(): JSX.Element;
    renderMultipe(): JSX.Element;
    renderSingle(): JSX.Element;
    render(): JSX.Element | null;
}
export declare class ComboControlRenderer extends ComboControl {
}
