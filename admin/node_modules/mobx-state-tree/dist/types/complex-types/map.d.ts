import { IInterceptor, IKeyValueMap, IMapDidChange, IMapWillChange, Lambda } from "mobx";
import { IAnyType, IComplexType, IType, OptionalProperty, ExtractC, ExtractS, ExtractT, ExtractCST } from "../../internal";
export interface IMapType<IT extends IAnyType> extends IComplexType<IKeyValueMap<ExtractC<IT>> | undefined, IKeyValueMap<ExtractS<IT>>, IMSTMap<IT>>, OptionalProperty {
}
export interface IMSTMap<IT extends IAnyType> {
    clear(): void;
    delete(key: string): boolean;
    forEach(callbackfn: (value: ExtractT<IT>, key: string, map: IMSTMap<IT>) => void, thisArg?: any): void;
    get(key: string): ExtractT<IT> | undefined;
    has(key: string): boolean;
    set(key: string, value: ExtractCST<IT>): this;
    readonly size: number;
    put(value: ExtractCST<IT>): ExtractT<IT>;
    keys(): IterableIterator<string>;
    values(): IterableIterator<ExtractT<IT>>;
    entries(): IterableIterator<[string, ExtractT<IT>]>;
    [Symbol.iterator](): IterableIterator<[string, ExtractT<IT>]>;
    /** Merge another object into this map, returns self. */
    merge(other: IMSTMap<IType<any, any, ExtractT<IT>>> | IKeyValueMap<ExtractCST<IT>> | any): this;
    replace(values: IMSTMap<IType<any, any, ExtractT<IT>>> | IKeyValueMap<ExtractT<IT>>): this;
    /**
     * Returns a plain object that represents this map.
     * Note that all the keys being stringified.
     * If there are duplicating keys after converting them to strings, behaviour is undetermined.
     */
    toPOJO(): IKeyValueMap<ExtractT<IT>>;
    /**
     * Returns a shallow non observable object clone of this map.
     * Note that the values migth still be observable. For a deep clone use mobx.toJS.
     */
    toJS(): Map<string, ExtractT<IT>>;
    toJSON(): IKeyValueMap<ExtractT<IT>>;
    toString(): string;
    [Symbol.toStringTag]: "Map";
    /**
     * Observes this object. Triggers for the events 'add', 'update' and 'delete'.
     * See: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/observe
     * for callback details
     */
    observe(listener: (changes: IMapDidChange<string, ExtractT<IT>>) => void, fireImmediately?: boolean): Lambda;
    intercept(handler: IInterceptor<IMapWillChange<string, ExtractT<IT>>>): Lambda;
}
/**
 * Creates a key based collection type who's children are all of a uniform declared type.
 * If the type stored in a map has an identifier, it is mandatory to store the child under that identifier in the map.
 *
 * This type will always produce [observable maps](https://mobx.js.org/refguide/map.html)
 *
 * @example
 * const Todo = types.model({
 *   id: types.identifier,
 *   task: types.string
 * })
 *
 * const TodoStore = types.model({
 *   todos: types.map(Todo)
 * })
 *
 * const s = TodoStore.create({ todos: {} })
 * unprotect(s)
 * s.todos.set(17, { task: "Grab coffee", id: 17 })
 * s.todos.put({ task: "Grab cookie", id: 18 }) // put will infer key from the identifier
 * console.log(s.todos.get(17).task) // prints: "Grab coffee"
 *
 * @export
 * @alias types.map
 * @param {IType<S, T>} subtype
 * @returns {IComplexType<S[], IObservableArray<T>>}
 */
export declare function map<IT extends IAnyType>(subtype: IT): IMapType<IT>;
/**
 * Returns if a given value represents a map type.
 *
 * @export
 * @template IT
 * @param {IT} type
 * @returns {type is IT}
 */
export declare function isMapType<IT extends IMapType<any>>(type: IT): type is IT;
