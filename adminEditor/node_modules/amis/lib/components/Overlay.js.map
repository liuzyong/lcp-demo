{
    "version": 3,
    "file": "Overlay.js",
    "sourceRoot": "",
    "sources": [
        "/src/components/Overlay.tsx"
    ],
    "names": [],
    "mappings": "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",
    "sourcesContent": [
        "/**\n * @file Overlay\n * @description\n * @author fex\n */\n\nimport {\n  Position as BasePosition,\n  Portal,\n  RootCloseWrapper\n} from 'react-overlays';\nimport {findDOMNode} from 'react-dom';\nimport React from 'react';\nimport {calculatePosition, getContainer, ownerDocument} from '../utils/dom';\nimport {autobind} from '../utils/helper';\nimport {resizeSensor, getComputedStyle} from '../utils/resize-sensor';\n\n// @ts-ignore\nBasePosition.propTypes.placement = () => null;\n\n// @ts-ignore\nclass Position extends BasePosition {\n  props: any;\n  _lastTarget: any;\n  resizeDispose: () => void;\n  watchedTarget: any;\n  setState: (state: any) => void;\n\n  updatePosition(target: any) {\n    this._lastTarget = target;\n\n    if (!target) {\n      return this.setState({\n        positionLeft: 0,\n        positionTop: 0,\n        arrowOffsetLeft: null,\n        arrowOffsetTop: null\n      });\n    }\n\n    if (\n      (!this.watchedTarget || this.watchedTarget !== target) &&\n      getComputedStyle(target, 'position') !== 'static'\n    ) {\n      this.resizeDispose?.();\n      this.watchedTarget = target;\n      this.resizeDispose = resizeSensor(target, () =>\n        this.updatePosition(target)\n      );\n    }\n\n    const overlay = findDOMNode(this as any);\n    const container = getContainer(\n      this.props.container,\n      ownerDocument(this).body\n    );\n\n    this.setState(\n      calculatePosition(\n        this.props.placement,\n        overlay,\n        target,\n        container,\n        this.props.containerPadding\n      )\n    );\n  }\n\n  componentWillUnmount() {\n    this.resizeDispose?.();\n  }\n}\n\ninterface OverlayProps {\n  placement?: string;\n  show?: boolean;\n  transition?: React.ReactType;\n  containerPadding?: number;\n  shouldUpdatePosition?: boolean;\n  rootClose?: boolean;\n  onHide?(props: any, ...args: any[]): any;\n  container?: React.ReactNode | Function;\n  target?: React.ReactNode | Function;\n\n  onEnter?(node: HTMLElement): any;\n  onEntering?(node: HTMLElement): any;\n  onEntered?(node: HTMLElement): any;\n  onExit?(node: HTMLElement): any;\n  onExiting?(node: HTMLElement): any;\n  onExited?(node: HTMLElement): any;\n}\ninterface OverlayState {\n  exited: boolean;\n}\nexport default class Overlay extends React.Component<\n  OverlayProps,\n  OverlayState\n> {\n  static defaultProps = {\n    placement: 'auto'\n  };\n  constructor(props: OverlayProps) {\n    super(props as any);\n\n    this.state = {\n      exited: !props.show\n    };\n  }\n\n  componentWillReceiveProps(nextProps: OverlayProps) {\n    if (nextProps.show) {\n      this.setState({exited: false});\n    } else if (!nextProps.transition) {\n      // Otherwise let handleHidden take care of marking exited.\n      this.setState({exited: true});\n    }\n  }\n\n  @autobind\n  onHiddenListener(node: HTMLElement) {\n    this.setState({exited: true});\n\n    if (this.props.onExited) {\n      this.props.onExited(node);\n    }\n  }\n\n  render() {\n    const {\n      container,\n      containerPadding,\n      target,\n      placement,\n      shouldUpdatePosition,\n      rootClose,\n      children,\n      transition: Transition,\n      ...props\n    } = this.props;\n\n    const mountOverlay = props.show || (Transition && !this.state.exited);\n    if (!mountOverlay) {\n      // Don't bother showing anything if we don't have to.\n      return null;\n    }\n\n    let child = children;\n\n    // Position is be inner-most because it adds inline styles into the child,\n    // which the other wrappers don't forward correctly.\n    child = (\n      // @ts-ignore\n      <Position\n        {...{\n          container,\n          containerPadding,\n          target,\n          placement,\n          shouldUpdatePosition\n        }}\n      >\n        {child}\n      </Position>\n    );\n\n    if (Transition) {\n      let {onExit, onExiting, onEnter, onEntering, onEntered} = props;\n\n      // This animates the child node by injecting props, so it must precede\n      // anything that adds a wrapping div.\n      child = (\n        <Transition\n          in={props.show}\n          appear\n          onExit={onExit}\n          onExiting={onExiting}\n          onExited={this.onHiddenListener}\n          onEnter={onEnter}\n          onEntering={onEntering}\n          onEntered={onEntered}\n        >\n          {child}\n        </Transition>\n      );\n    }\n\n    // This goes after everything else because it adds a wrapping div.\n    if (rootClose) {\n      child = (\n        // @ts-ignore\n        <RootCloseWrapper onRootClose={props.onHide}>{child}</RootCloseWrapper>\n      );\n    }\n\n    // @ts-ignore\n    return <Portal container={container}>{child}</Portal>;\n  }\n}\n"
    ]
}