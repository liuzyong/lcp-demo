define('node_modules/monaco-editor/esm/vs/editor/contrib/smartSelect/wordSelections', function(require, exports, module) {

  "use strict";
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.WordSelectionRangeProvider = void 0;
  /*---------------------------------------------------------------------------------------------
   *  Copyright (c) Microsoft Corporation. All rights reserved.
   *  Licensed under the MIT License. See License.txt in the project root for license information.
   *--------------------------------------------------------------------------------------------*/
  var range_js_1 = require("node_modules/monaco-editor/esm/vs/editor/common/core/range");
  var strings_js_1 = require("node_modules/monaco-editor/esm/vs/base/common/strings");
  var WordSelectionRangeProvider = /** @class */ (function () {
      function WordSelectionRangeProvider() {
      }
      WordSelectionRangeProvider.prototype.provideSelectionRanges = function (model, positions) {
          var result = [];
          for (var _i = 0, positions_1 = positions; _i < positions_1.length; _i++) {
              var position = positions_1[_i];
              var bucket = [];
              result.push(bucket);
              this._addInWordRanges(bucket, model, position);
              this._addWordRanges(bucket, model, position);
              this._addWhitespaceLine(bucket, model, position);
              bucket.push({ range: model.getFullModelRange(), kind: 'statement.all' });
          }
          return result;
      };
      WordSelectionRangeProvider.prototype._addInWordRanges = function (bucket, model, pos) {
          var obj = model.getWordAtPosition(pos);
          if (!obj) {
              return;
          }
          var word = obj.word, startColumn = obj.startColumn;
          var offset = pos.column - startColumn;
          var start = offset;
          var end = offset;
          var lastCh = 0;
          // LEFT anchor (start)
          for (; start >= 0; start--) {
              var ch = word.charCodeAt(start);
              if (ch === 95 /* Underline */ || ch === 45 /* Dash */) {
                  // foo-bar OR foo_bar
                  break;
              }
              else if (strings_js_1.isLowerAsciiLetter(ch) && strings_js_1.isUpperAsciiLetter(lastCh)) {
                  // fooBar
                  break;
              }
              lastCh = ch;
          }
          start += 1;
          // RIGHT anchor (end)
          for (; end < word.length; end++) {
              var ch = word.charCodeAt(end);
              if (strings_js_1.isUpperAsciiLetter(ch) && strings_js_1.isLowerAsciiLetter(lastCh)) {
                  // fooBar
                  break;
              }
              else if (ch === 95 /* Underline */ || ch === 45 /* Dash */) {
                  // foo-bar OR foo_bar
                  break;
              }
              lastCh = ch;
          }
          if (start < end) {
              bucket.push({ range: new range_js_1.Range(pos.lineNumber, startColumn + start, pos.lineNumber, startColumn + end), kind: 'statement.word.part' });
          }
      };
      WordSelectionRangeProvider.prototype._addWordRanges = function (bucket, model, pos) {
          var word = model.getWordAtPosition(pos);
          if (word) {
              bucket.push({ range: new range_js_1.Range(pos.lineNumber, word.startColumn, pos.lineNumber, word.endColumn), kind: 'statement.word' });
          }
      };
      WordSelectionRangeProvider.prototype._addWhitespaceLine = function (bucket, model, pos) {
          if (model.getLineLength(pos.lineNumber) > 0
              && model.getLineFirstNonWhitespaceColumn(pos.lineNumber) === 0
              && model.getLineLastNonWhitespaceColumn(pos.lineNumber) === 0) {
              bucket.push({ range: new range_js_1.Range(pos.lineNumber, 1, pos.lineNumber, model.getLineMaxColumn(pos.lineNumber)), kind: 'statement.line' });
          }
      };
      return WordSelectionRangeProvider;
  }());
  exports.WordSelectionRangeProvider = WordSelectionRangeProvider;
  

});
