define('node_modules/monaco-editor/esm/vs/editor/standalone/browser/standaloneLanguages', function(require, exports, module) {

  "use strict";
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.createMonacoLanguagesAPI = exports.registerFoldingRangeProvider = exports.registerColorProvider = exports.registerCompletionItemProvider = exports.registerLinkProvider = exports.registerOnTypeFormattingEditProvider = exports.registerDocumentRangeFormattingEditProvider = exports.registerDocumentFormattingEditProvider = exports.registerCodeActionProvider = exports.registerCodeLensProvider = exports.registerTypeDefinitionProvider = exports.registerImplementationProvider = exports.registerDefinitionProvider = exports.registerDocumentHighlightProvider = exports.registerDocumentSymbolProvider = exports.registerHoverProvider = exports.registerSignatureHelpProvider = exports.registerRenameProvider = exports.registerReferenceProvider = exports.setMonarchTokensProvider = exports.setTokensProvider = exports.TokenizationSupport2Adapter = exports.EncodedTokenizationSupport2Adapter = exports.setLanguageConfiguration = exports.onLanguage = exports.getEncodedLanguageId = exports.getLanguages = exports.register = void 0;
  var tslib_1 = require("node_modules/tslib/tslib");
  /*---------------------------------------------------------------------------------------------
   *  Copyright (c) Microsoft Corporation. All rights reserved.
   *  Licensed under the MIT License. See License.txt in the project root for license information.
   *--------------------------------------------------------------------------------------------*/
  var range_js_1 = require("node_modules/monaco-editor/esm/vs/editor/common/core/range");
  var token_js_1 = require("node_modules/monaco-editor/esm/vs/editor/common/core/token");
  var modes = tslib_1.__importStar(require("node_modules/monaco-editor/esm/vs/editor/common/modes"));
  var languageConfigurationRegistry_js_1 = require("node_modules/monaco-editor/esm/vs/editor/common/modes/languageConfigurationRegistry");
  var modesRegistry_js_1 = require("node_modules/monaco-editor/esm/vs/editor/common/modes/modesRegistry");
  var standaloneEnums = tslib_1.__importStar(require("node_modules/monaco-editor/esm/vs/editor/common/standalone/standaloneEnums"));
  var standaloneServices_js_1 = require("node_modules/monaco-editor/esm/vs/editor/standalone/browser/standaloneServices");
  var monarchCompile_js_1 = require("node_modules/monaco-editor/esm/vs/editor/standalone/common/monarch/monarchCompile");
  var monarchLexer_js_1 = require("node_modules/monaco-editor/esm/vs/editor/standalone/common/monarch/monarchLexer");
  /**
   * Register information about a new language.
   */
  function register(language) {
      modesRegistry_js_1.ModesRegistry.registerLanguage(language);
  }
  exports.register = register;
  /**
   * Get the information of all the registered languages.
   */
  function getLanguages() {
      var result = [];
      result = result.concat(modesRegistry_js_1.ModesRegistry.getLanguages());
      return result;
  }
  exports.getLanguages = getLanguages;
  function getEncodedLanguageId(languageId) {
      var lid = standaloneServices_js_1.StaticServices.modeService.get().getLanguageIdentifier(languageId);
      return lid ? lid.id : 0;
  }
  exports.getEncodedLanguageId = getEncodedLanguageId;
  /**
   * An event emitted when a language is first time needed (e.g. a model has it set).
   * @event
   */
  function onLanguage(languageId, callback) {
      var disposable = standaloneServices_js_1.StaticServices.modeService.get().onDidCreateMode(function (mode) {
          if (mode.getId() === languageId) {
              // stop listening
              disposable.dispose();
              // invoke actual listener
              callback();
          }
      });
      return disposable;
  }
  exports.onLanguage = onLanguage;
  /**
   * Set the editing configuration for a language.
   */
  function setLanguageConfiguration(languageId, configuration) {
      var languageIdentifier = standaloneServices_js_1.StaticServices.modeService.get().getLanguageIdentifier(languageId);
      if (!languageIdentifier) {
          throw new Error("Cannot set configuration for unknown language " + languageId);
      }
      return languageConfigurationRegistry_js_1.LanguageConfigurationRegistry.register(languageIdentifier, configuration);
  }
  exports.setLanguageConfiguration = setLanguageConfiguration;
  /**
   * @internal
   */
  var EncodedTokenizationSupport2Adapter = /** @class */ (function () {
      function EncodedTokenizationSupport2Adapter(actual) {
          this._actual = actual;
      }
      EncodedTokenizationSupport2Adapter.prototype.getInitialState = function () {
          return this._actual.getInitialState();
      };
      EncodedTokenizationSupport2Adapter.prototype.tokenize = function (line, state, offsetDelta) {
          throw new Error('Not supported!');
      };
      EncodedTokenizationSupport2Adapter.prototype.tokenize2 = function (line, state) {
          var result = this._actual.tokenizeEncoded(line, state);
          return new token_js_1.TokenizationResult2(result.tokens, result.endState);
      };
      return EncodedTokenizationSupport2Adapter;
  }());
  exports.EncodedTokenizationSupport2Adapter = EncodedTokenizationSupport2Adapter;
  /**
   * @internal
   */
  var TokenizationSupport2Adapter = /** @class */ (function () {
      function TokenizationSupport2Adapter(standaloneThemeService, languageIdentifier, actual) {
          this._standaloneThemeService = standaloneThemeService;
          this._languageIdentifier = languageIdentifier;
          this._actual = actual;
      }
      TokenizationSupport2Adapter.prototype.getInitialState = function () {
          return this._actual.getInitialState();
      };
      TokenizationSupport2Adapter.prototype._toClassicTokens = function (tokens, language, offsetDelta) {
          var result = [];
          var previousStartIndex = 0;
          for (var i = 0, len = tokens.length; i < len; i++) {
              var t = tokens[i];
              var startIndex = t.startIndex;
              // Prevent issues stemming from a buggy external tokenizer.
              if (i === 0) {
                  // Force first token to start at first index!
                  startIndex = 0;
              }
              else if (startIndex < previousStartIndex) {
                  // Force tokens to be after one another!
                  startIndex = previousStartIndex;
              }
              result[i] = new token_js_1.Token(startIndex + offsetDelta, t.scopes, language);
              previousStartIndex = startIndex;
          }
          return result;
      };
      TokenizationSupport2Adapter.prototype.tokenize = function (line, state, offsetDelta) {
          var actualResult = this._actual.tokenize(line, state);
          var tokens = this._toClassicTokens(actualResult.tokens, this._languageIdentifier.language, offsetDelta);
          var endState;
          // try to save an object if possible
          if (actualResult.endState.equals(state)) {
              endState = state;
          }
          else {
              endState = actualResult.endState;
          }
          return new token_js_1.TokenizationResult(tokens, endState);
      };
      TokenizationSupport2Adapter.prototype._toBinaryTokens = function (tokens, offsetDelta) {
          var languageId = this._languageIdentifier.id;
          var tokenTheme = this._standaloneThemeService.getTheme().tokenTheme;
          var result = [], resultLen = 0;
          var previousStartIndex = 0;
          for (var i = 0, len = tokens.length; i < len; i++) {
              var t = tokens[i];
              var metadata = tokenTheme.match(languageId, t.scopes);
              if (resultLen > 0 && result[resultLen - 1] === metadata) {
                  // same metadata
                  continue;
              }
              var startIndex = t.startIndex;
              // Prevent issues stemming from a buggy external tokenizer.
              if (i === 0) {
                  // Force first token to start at first index!
                  startIndex = 0;
              }
              else if (startIndex < previousStartIndex) {
                  // Force tokens to be after one another!
                  startIndex = previousStartIndex;
              }
              result[resultLen++] = startIndex + offsetDelta;
              result[resultLen++] = metadata;
              previousStartIndex = startIndex;
          }
          var actualResult = new Uint32Array(resultLen);
          for (var i = 0; i < resultLen; i++) {
              actualResult[i] = result[i];
          }
          return actualResult;
      };
      TokenizationSupport2Adapter.prototype.tokenize2 = function (line, state, offsetDelta) {
          var actualResult = this._actual.tokenize(line, state);
          var tokens = this._toBinaryTokens(actualResult.tokens, offsetDelta);
          var endState;
          // try to save an object if possible
          if (actualResult.endState.equals(state)) {
              endState = state;
          }
          else {
              endState = actualResult.endState;
          }
          return new token_js_1.TokenizationResult2(tokens, endState);
      };
      return TokenizationSupport2Adapter;
  }());
  exports.TokenizationSupport2Adapter = TokenizationSupport2Adapter;
  function isEncodedTokensProvider(provider) {
      return provider['tokenizeEncoded'];
  }
  function isThenable(obj) {
      if (typeof obj.then === 'function') {
          return true;
      }
      return false;
  }
  /**
   * Set the tokens provider for a language (manual implementation).
   */
  function setTokensProvider(languageId, provider) {
      var languageIdentifier = standaloneServices_js_1.StaticServices.modeService.get().getLanguageIdentifier(languageId);
      if (!languageIdentifier) {
          throw new Error("Cannot set tokens provider for unknown language " + languageId);
      }
      var create = function (provider) {
          if (isEncodedTokensProvider(provider)) {
              return new EncodedTokenizationSupport2Adapter(provider);
          }
          else {
              return new TokenizationSupport2Adapter(standaloneServices_js_1.StaticServices.standaloneThemeService.get(), languageIdentifier, provider);
          }
      };
      if (isThenable(provider)) {
          return modes.TokenizationRegistry.registerPromise(languageId, provider.then(function (provider) { return create(provider); }));
      }
      return modes.TokenizationRegistry.register(languageId, create(provider));
  }
  exports.setTokensProvider = setTokensProvider;
  /**
   * Set the tokens provider for a language (monarch implementation).
   */
  function setMonarchTokensProvider(languageId, languageDef) {
      var create = function (languageDef) {
          return monarchLexer_js_1.createTokenizationSupport(standaloneServices_js_1.StaticServices.modeService.get(), standaloneServices_js_1.StaticServices.standaloneThemeService.get(), languageId, monarchCompile_js_1.compile(languageId, languageDef));
      };
      if (isThenable(languageDef)) {
          return modes.TokenizationRegistry.registerPromise(languageId, languageDef.then(function (languageDef) { return create(languageDef); }));
      }
      return modes.TokenizationRegistry.register(languageId, create(languageDef));
  }
  exports.setMonarchTokensProvider = setMonarchTokensProvider;
  /**
   * Register a reference provider (used by e.g. reference search).
   */
  function registerReferenceProvider(languageId, provider) {
      return modes.ReferenceProviderRegistry.register(languageId, provider);
  }
  exports.registerReferenceProvider = registerReferenceProvider;
  /**
   * Register a rename provider (used by e.g. rename symbol).
   */
  function registerRenameProvider(languageId, provider) {
      return modes.RenameProviderRegistry.register(languageId, provider);
  }
  exports.registerRenameProvider = registerRenameProvider;
  /**
   * Register a signature help provider (used by e.g. parameter hints).
   */
  function registerSignatureHelpProvider(languageId, provider) {
      return modes.SignatureHelpProviderRegistry.register(languageId, provider);
  }
  exports.registerSignatureHelpProvider = registerSignatureHelpProvider;
  /**
   * Register a hover provider (used by e.g. editor hover).
   */
  function registerHoverProvider(languageId, provider) {
      return modes.HoverProviderRegistry.register(languageId, {
          provideHover: function (model, position, token) {
              var word = model.getWordAtPosition(position);
              return Promise.resolve(provider.provideHover(model, position, token)).then(function (value) {
                  if (!value) {
                      return undefined;
                  }
                  if (!value.range && word) {
                      value.range = new range_js_1.Range(position.lineNumber, word.startColumn, position.lineNumber, word.endColumn);
                  }
                  if (!value.range) {
                      value.range = new range_js_1.Range(position.lineNumber, position.column, position.lineNumber, position.column);
                  }
                  return value;
              });
          }
      });
  }
  exports.registerHoverProvider = registerHoverProvider;
  /**
   * Register a document symbol provider (used by e.g. outline).
   */
  function registerDocumentSymbolProvider(languageId, provider) {
      return modes.DocumentSymbolProviderRegistry.register(languageId, provider);
  }
  exports.registerDocumentSymbolProvider = registerDocumentSymbolProvider;
  /**
   * Register a document highlight provider (used by e.g. highlight occurrences).
   */
  function registerDocumentHighlightProvider(languageId, provider) {
      return modes.DocumentHighlightProviderRegistry.register(languageId, provider);
  }
  exports.registerDocumentHighlightProvider = registerDocumentHighlightProvider;
  /**
   * Register a definition provider (used by e.g. go to definition).
   */
  function registerDefinitionProvider(languageId, provider) {
      return modes.DefinitionProviderRegistry.register(languageId, provider);
  }
  exports.registerDefinitionProvider = registerDefinitionProvider;
  /**
   * Register a implementation provider (used by e.g. go to implementation).
   */
  function registerImplementationProvider(languageId, provider) {
      return modes.ImplementationProviderRegistry.register(languageId, provider);
  }
  exports.registerImplementationProvider = registerImplementationProvider;
  /**
   * Register a type definition provider (used by e.g. go to type definition).
   */
  function registerTypeDefinitionProvider(languageId, provider) {
      return modes.TypeDefinitionProviderRegistry.register(languageId, provider);
  }
  exports.registerTypeDefinitionProvider = registerTypeDefinitionProvider;
  /**
   * Register a code lens provider (used by e.g. inline code lenses).
   */
  function registerCodeLensProvider(languageId, provider) {
      return modes.CodeLensProviderRegistry.register(languageId, provider);
  }
  exports.registerCodeLensProvider = registerCodeLensProvider;
  /**
   * Register a code action provider (used by e.g. quick fix).
   */
  function registerCodeActionProvider(languageId, provider) {
      return modes.CodeActionProviderRegistry.register(languageId, {
          provideCodeActions: function (model, range, context, token) {
              var markers = standaloneServices_js_1.StaticServices.markerService.get().read({ resource: model.uri }).filter(function (m) {
                  return range_js_1.Range.areIntersectingOrTouching(m, range);
              });
              return provider.provideCodeActions(model, range, { markers: markers, only: context.only }, token);
          }
      });
  }
  exports.registerCodeActionProvider = registerCodeActionProvider;
  /**
   * Register a formatter that can handle only entire models.
   */
  function registerDocumentFormattingEditProvider(languageId, provider) {
      return modes.DocumentFormattingEditProviderRegistry.register(languageId, provider);
  }
  exports.registerDocumentFormattingEditProvider = registerDocumentFormattingEditProvider;
  /**
   * Register a formatter that can handle a range inside a model.
   */
  function registerDocumentRangeFormattingEditProvider(languageId, provider) {
      return modes.DocumentRangeFormattingEditProviderRegistry.register(languageId, provider);
  }
  exports.registerDocumentRangeFormattingEditProvider = registerDocumentRangeFormattingEditProvider;
  /**
   * Register a formatter than can do formatting as the user types.
   */
  function registerOnTypeFormattingEditProvider(languageId, provider) {
      return modes.OnTypeFormattingEditProviderRegistry.register(languageId, provider);
  }
  exports.registerOnTypeFormattingEditProvider = registerOnTypeFormattingEditProvider;
  /**
   * Register a link provider that can find links in text.
   */
  function registerLinkProvider(languageId, provider) {
      return modes.LinkProviderRegistry.register(languageId, provider);
  }
  exports.registerLinkProvider = registerLinkProvider;
  /**
   * Register a completion item provider (use by e.g. suggestions).
   */
  function registerCompletionItemProvider(languageId, provider) {
      return modes.CompletionProviderRegistry.register(languageId, provider);
  }
  exports.registerCompletionItemProvider = registerCompletionItemProvider;
  /**
   * Register a document color provider (used by Color Picker, Color Decorator).
   */
  function registerColorProvider(languageId, provider) {
      return modes.ColorProviderRegistry.register(languageId, provider);
  }
  exports.registerColorProvider = registerColorProvider;
  /**
   * Register a folding range provider
   */
  function registerFoldingRangeProvider(languageId, provider) {
      return modes.FoldingRangeProviderRegistry.register(languageId, provider);
  }
  exports.registerFoldingRangeProvider = registerFoldingRangeProvider;
  /**
   * @internal
   */
  function createMonacoLanguagesAPI() {
      return {
          register: register,
          getLanguages: getLanguages,
          onLanguage: onLanguage,
          getEncodedLanguageId: getEncodedLanguageId,
          // provider methods
          setLanguageConfiguration: setLanguageConfiguration,
          setTokensProvider: setTokensProvider,
          setMonarchTokensProvider: setMonarchTokensProvider,
          registerReferenceProvider: registerReferenceProvider,
          registerRenameProvider: registerRenameProvider,
          registerCompletionItemProvider: registerCompletionItemProvider,
          registerSignatureHelpProvider: registerSignatureHelpProvider,
          registerHoverProvider: registerHoverProvider,
          registerDocumentSymbolProvider: registerDocumentSymbolProvider,
          registerDocumentHighlightProvider: registerDocumentHighlightProvider,
          registerDefinitionProvider: registerDefinitionProvider,
          registerImplementationProvider: registerImplementationProvider,
          registerTypeDefinitionProvider: registerTypeDefinitionProvider,
          registerCodeLensProvider: registerCodeLensProvider,
          registerCodeActionProvider: registerCodeActionProvider,
          registerDocumentFormattingEditProvider: registerDocumentFormattingEditProvider,
          registerDocumentRangeFormattingEditProvider: registerDocumentRangeFormattingEditProvider,
          registerOnTypeFormattingEditProvider: registerOnTypeFormattingEditProvider,
          registerLinkProvider: registerLinkProvider,
          registerColorProvider: registerColorProvider,
          registerFoldingRangeProvider: registerFoldingRangeProvider,
          // enums
          DocumentHighlightKind: standaloneEnums.DocumentHighlightKind,
          CompletionItemKind: standaloneEnums.CompletionItemKind,
          CompletionItemInsertTextRule: standaloneEnums.CompletionItemInsertTextRule,
          SymbolKind: standaloneEnums.SymbolKind,
          IndentAction: standaloneEnums.IndentAction,
          CompletionTriggerKind: standaloneEnums.CompletionTriggerKind,
          SignatureHelpTriggerKind: standaloneEnums.SignatureHelpTriggerKind,
          // classes
          FoldingRangeKind: modes.FoldingRangeKind,
      };
  }
  exports.createMonacoLanguagesAPI = createMonacoLanguagesAPI;
  

});
