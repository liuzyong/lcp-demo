define('node_modules/monaco-editor/esm/vs/base/browser/dom', function(require, exports, module) {

  "use strict";
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.animate = exports.windowOpenNoOpener = exports.computeScreenAwareSize = exports.getElementsByTagName = exports.removeTabIndexAndUpdateFocus = exports.hide = exports.show = exports.$ = exports.append = exports.trackFocus = exports.restoreParentsScrollTop = exports.saveParentsScrollTop = exports.EventHelper = exports.EventType = exports.isHTMLElement = exports.removeCSSRulesContainingSelector = exports.createCSSRule = exports.createStyleSheet = exports.findParentWithClass = exports.isAncestor = exports.getTotalHeight = exports.getContentHeight = exports.getContentWidth = exports.getTotalWidth = exports.StandardWindow = exports.getDomNodePagePosition = exports.getTopLeftOffset = exports.Dimension = exports.getComputedStyle = exports.addDisposableThrottledListener = exports.scheduleAtNextAnimationFrame = exports.runAtThisOrScheduleAtNextAnimationFrame = exports.addDisposableNonBubblingMouseOutListener = exports.addStandardDisposableListener = exports.addDisposableListener = exports.toggleClass = exports.removeClasses = exports.removeClass = exports.addClasses = exports.addClass = exports.hasClass = exports.isInDOM = exports.removeNode = exports.clearNode = void 0;
  var tslib_1 = require("node_modules/tslib/tslib");
  /*---------------------------------------------------------------------------------------------
   *  Copyright (c) Microsoft Corporation. All rights reserved.
   *  Licensed under the MIT License. See License.txt in the project root for license information.
   *--------------------------------------------------------------------------------------------*/
  var __extends = (this && this.__extends) || (function () {
      var extendStatics = function (d, b) {
          extendStatics = Object.setPrototypeOf ||
              ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
              function (d, b) { for (var p in b)
                  if (b.hasOwnProperty(p))
                      d[p] = b[p]; };
          return extendStatics(d, b);
      };
      return function (d, b) {
          extendStatics(d, b);
          function __() { this.constructor = d; }
          d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
  })();
  var browser = tslib_1.__importStar(require("node_modules/monaco-editor/esm/vs/base/browser/browser"));
  var event_js_1 = require("node_modules/monaco-editor/esm/vs/base/browser/event");
  var keyboardEvent_js_1 = require("node_modules/monaco-editor/esm/vs/base/browser/keyboardEvent");
  var mouseEvent_js_1 = require("node_modules/monaco-editor/esm/vs/base/browser/mouseEvent");
  var async_js_1 = require("node_modules/monaco-editor/esm/vs/base/common/async");
  var errors_js_1 = require("node_modules/monaco-editor/esm/vs/base/common/errors");
  var event_js_2 = require("node_modules/monaco-editor/esm/vs/base/common/event");
  var lifecycle_js_1 = require("node_modules/monaco-editor/esm/vs/base/common/lifecycle");
  var platform = tslib_1.__importStar(require("node_modules/monaco-editor/esm/vs/base/common/platform"));
  var arrays_js_1 = require("node_modules/monaco-editor/esm/vs/base/common/arrays");
  function clearNode(node) {
      while (node.firstChild) {
          node.removeChild(node.firstChild);
      }
  }
  exports.clearNode = clearNode;
  function removeNode(node) {
      if (node.parentNode) {
          node.parentNode.removeChild(node);
      }
  }
  exports.removeNode = removeNode;
  function isInDOM(node) {
      while (node) {
          if (node === document.body) {
              return true;
          }
          node = node.parentNode;
      }
      return false;
  }
  exports.isInDOM = isInDOM;
  var _manualClassList = new /** @class */ (function () {
      function class_1() {
      }
      class_1.prototype._findClassName = function (node, className) {
          var classes = node.className;
          if (!classes) {
              this._lastStart = -1;
              return;
          }
          className = className.trim();
          var classesLen = classes.length, classLen = className.length;
          if (classLen === 0) {
              this._lastStart = -1;
              return;
          }
          if (classesLen < classLen) {
              this._lastStart = -1;
              return;
          }
          if (classes === className) {
              this._lastStart = 0;
              this._lastEnd = classesLen;
              return;
          }
          var idx = -1, idxEnd;
          while ((idx = classes.indexOf(className, idx + 1)) >= 0) {
              idxEnd = idx + classLen;
              // a class that is followed by another class
              if ((idx === 0 || classes.charCodeAt(idx - 1) === 32 /* Space */) && classes.charCodeAt(idxEnd) === 32 /* Space */) {
                  this._lastStart = idx;
                  this._lastEnd = idxEnd + 1;
                  return;
              }
              // last class
              if (idx > 0 && classes.charCodeAt(idx - 1) === 32 /* Space */ && idxEnd === classesLen) {
                  this._lastStart = idx - 1;
                  this._lastEnd = idxEnd;
                  return;
              }
              // equal - duplicate of cmp above
              if (idx === 0 && idxEnd === classesLen) {
                  this._lastStart = 0;
                  this._lastEnd = idxEnd;
                  return;
              }
          }
          this._lastStart = -1;
      };
      class_1.prototype.hasClass = function (node, className) {
          this._findClassName(node, className);
          return this._lastStart !== -1;
      };
      class_1.prototype.addClasses = function (node) {
          var _this = this;
          var classNames = [];
          for (var _i = 1; _i < arguments.length; _i++) {
              classNames[_i - 1] = arguments[_i];
          }
          classNames.forEach(function (nameValue) { return nameValue.split(' ').forEach(function (name) { return _this.addClass(node, name); }); });
      };
      class_1.prototype.addClass = function (node, className) {
          if (!node.className) { // doesn't have it for sure
              node.className = className;
          }
          else {
              this._findClassName(node, className); // see if it's already there
              if (this._lastStart === -1) {
                  node.className = node.className + ' ' + className;
              }
          }
      };
      class_1.prototype.removeClass = function (node, className) {
          this._findClassName(node, className);
          if (this._lastStart === -1) {
              return; // Prevent styles invalidation if not necessary
          }
          else {
              node.className = node.className.substring(0, this._lastStart) + node.className.substring(this._lastEnd);
          }
      };
      class_1.prototype.removeClasses = function (node) {
          var _this = this;
          var classNames = [];
          for (var _i = 1; _i < arguments.length; _i++) {
              classNames[_i - 1] = arguments[_i];
          }
          classNames.forEach(function (nameValue) { return nameValue.split(' ').forEach(function (name) { return _this.removeClass(node, name); }); });
      };
      class_1.prototype.toggleClass = function (node, className, shouldHaveIt) {
          this._findClassName(node, className);
          if (this._lastStart !== -1 && (shouldHaveIt === undefined || !shouldHaveIt)) {
              this.removeClass(node, className);
          }
          if (this._lastStart === -1 && (shouldHaveIt === undefined || shouldHaveIt)) {
              this.addClass(node, className);
          }
      };
      return class_1;
  }());
  var _nativeClassList = new /** @class */ (function () {
      function class_2() {
      }
      class_2.prototype.hasClass = function (node, className) {
          return Boolean(className) && node.classList && node.classList.contains(className);
      };
      class_2.prototype.addClasses = function (node) {
          var _this = this;
          var classNames = [];
          for (var _i = 1; _i < arguments.length; _i++) {
              classNames[_i - 1] = arguments[_i];
          }
          classNames.forEach(function (nameValue) { return nameValue.split(' ').forEach(function (name) { return _this.addClass(node, name); }); });
      };
      class_2.prototype.addClass = function (node, className) {
          if (className && node.classList) {
              node.classList.add(className);
          }
      };
      class_2.prototype.removeClass = function (node, className) {
          if (className && node.classList) {
              node.classList.remove(className);
          }
      };
      class_2.prototype.removeClasses = function (node) {
          var _this = this;
          var classNames = [];
          for (var _i = 1; _i < arguments.length; _i++) {
              classNames[_i - 1] = arguments[_i];
          }
          classNames.forEach(function (nameValue) { return nameValue.split(' ').forEach(function (name) { return _this.removeClass(node, name); }); });
      };
      class_2.prototype.toggleClass = function (node, className, shouldHaveIt) {
          if (node.classList) {
              node.classList.toggle(className, shouldHaveIt);
          }
      };
      return class_2;
  }());
  // In IE11 there is only partial support for `classList` which makes us keep our
  // custom implementation. Otherwise use the native implementation, see: http://caniuse.com/#search=classlist
  var _classList = browser.isIE ? _manualClassList : _nativeClassList;
  exports.hasClass = _classList.hasClass.bind(_classList);
  exports.addClass = _classList.addClass.bind(_classList);
  exports.addClasses = _classList.addClasses.bind(_classList);
  exports.removeClass = _classList.removeClass.bind(_classList);
  exports.removeClasses = _classList.removeClasses.bind(_classList);
  exports.toggleClass = _classList.toggleClass.bind(_classList);
  var DomListener = /** @class */ (function () {
      function DomListener(node, type, handler, useCapture) {
          this._node = node;
          this._type = type;
          this._handler = handler;
          this._useCapture = (useCapture || false);
          this._node.addEventListener(this._type, this._handler, this._useCapture);
      }
      DomListener.prototype.dispose = function () {
          if (!this._handler) {
              // Already disposed
              return;
          }
          this._node.removeEventListener(this._type, this._handler, this._useCapture);
          // Prevent leakers from holding on to the dom or handler func
          this._node = null;
          this._handler = null;
      };
      return DomListener;
  }());
  function addDisposableListener(node, type, handler, useCapture) {
      return new DomListener(node, type, handler, useCapture);
  }
  exports.addDisposableListener = addDisposableListener;
  function _wrapAsStandardMouseEvent(handler) {
      return function (e) {
          return handler(new mouseEvent_js_1.StandardMouseEvent(e));
      };
  }
  function _wrapAsStandardKeyboardEvent(handler) {
      return function (e) {
          return handler(new keyboardEvent_js_1.StandardKeyboardEvent(e));
      };
  }
  exports.addStandardDisposableListener = function addStandardDisposableListener(node, type, handler, useCapture) {
      var wrapHandler = handler;
      if (type === 'click' || type === 'mousedown') {
          wrapHandler = _wrapAsStandardMouseEvent(handler);
      }
      else if (type === 'keydown' || type === 'keypress' || type === 'keyup') {
          wrapHandler = _wrapAsStandardKeyboardEvent(handler);
      }
      return addDisposableListener(node, type, wrapHandler, useCapture);
  };
  function addDisposableNonBubblingMouseOutListener(node, handler) {
      return addDisposableListener(node, 'mouseout', function (e) {
          // Mouse out bubbles, so this is an attempt to ignore faux mouse outs coming from children elements
          var toElement = (e.relatedTarget || e.target);
          while (toElement && toElement !== node) {
              toElement = toElement.parentNode;
          }
          if (toElement === node) {
              return;
          }
          handler(e);
      });
  }
  exports.addDisposableNonBubblingMouseOutListener = addDisposableNonBubblingMouseOutListener;
  var _animationFrame = null;
  function doRequestAnimationFrame(callback) {
      if (!_animationFrame) {
          var emulatedRequestAnimationFrame = function (callback) {
              return setTimeout(function () { return callback(new Date().getTime()); }, 0);
          };
          _animationFrame = (self.requestAnimationFrame
              || self.msRequestAnimationFrame
              || self.webkitRequestAnimationFrame
              || self.mozRequestAnimationFrame
              || self.oRequestAnimationFrame
              || emulatedRequestAnimationFrame);
      }
      return _animationFrame.call(self, callback);
  }
  var AnimationFrameQueueItem = /** @class */ (function () {
      function AnimationFrameQueueItem(runner, priority) {
          if (priority === void 0) {
              priority = 0;
          }
          this._runner = runner;
          this.priority = priority;
          this._canceled = false;
      }
      AnimationFrameQueueItem.prototype.dispose = function () {
          this._canceled = true;
      };
      AnimationFrameQueueItem.prototype.execute = function () {
          if (this._canceled) {
              return;
          }
          try {
              this._runner();
          }
          catch (e) {
              errors_js_1.onUnexpectedError(e);
          }
      };
      // Sort by priority (largest to lowest)
      AnimationFrameQueueItem.sort = function (a, b) {
          return b.priority - a.priority;
      };
      return AnimationFrameQueueItem;
  }());
  (function () {
      /**
       * The runners scheduled at the next animation frame
       */
      var NEXT_QUEUE = [];
      /**
       * The runners scheduled at the current animation frame
       */
      var CURRENT_QUEUE = null;
      /**
       * A flag to keep track if the native requestAnimationFrame was already called
       */
      var animFrameRequested = false;
      /**
       * A flag to indicate if currently handling a native requestAnimationFrame callback
       */
      var inAnimationFrameRunner = false;
      var animationFrameRunner = function () {
          animFrameRequested = false;
          CURRENT_QUEUE = NEXT_QUEUE;
          NEXT_QUEUE = [];
          inAnimationFrameRunner = true;
          while (CURRENT_QUEUE.length > 0) {
              CURRENT_QUEUE.sort(AnimationFrameQueueItem.sort);
              var top_1 = CURRENT_QUEUE.shift();
              top_1.execute();
          }
          inAnimationFrameRunner = false;
      };
      exports.scheduleAtNextAnimationFrame = function (runner, priority) {
          if (priority === void 0) {
              priority = 0;
          }
          var item = new AnimationFrameQueueItem(runner, priority);
          NEXT_QUEUE.push(item);
          if (!animFrameRequested) {
              animFrameRequested = true;
              doRequestAnimationFrame(animationFrameRunner);
          }
          return item;
      };
      exports.runAtThisOrScheduleAtNextAnimationFrame = function (runner, priority) {
          if (inAnimationFrameRunner) {
              var item = new AnimationFrameQueueItem(runner, priority);
              CURRENT_QUEUE.push(item);
              return item;
          }
          else {
              return exports.scheduleAtNextAnimationFrame(runner, priority);
          }
      };
  })();
  var MINIMUM_TIME_MS = 16;
  var DEFAULT_EVENT_MERGER = function (lastEvent, currentEvent) {
      return currentEvent;
  };
  var TimeoutThrottledDomListener = /** @class */ (function (_super) {
      __extends(TimeoutThrottledDomListener, _super);
      function TimeoutThrottledDomListener(node, type, handler, eventMerger, minimumTimeMs) {
          if (eventMerger === void 0) {
              eventMerger = DEFAULT_EVENT_MERGER;
          }
          if (minimumTimeMs === void 0) {
              minimumTimeMs = MINIMUM_TIME_MS;
          }
          var _this = _super.call(this) || this;
          var lastEvent = null;
          var lastHandlerTime = 0;
          var timeout = _this._register(new async_js_1.TimeoutTimer());
          var invokeHandler = function () {
              lastHandlerTime = (new Date()).getTime();
              handler(lastEvent);
              lastEvent = null;
          };
          _this._register(addDisposableListener(node, type, function (e) {
              lastEvent = eventMerger(lastEvent, e);
              var elapsedTime = (new Date()).getTime() - lastHandlerTime;
              if (elapsedTime >= minimumTimeMs) {
                  timeout.cancel();
                  invokeHandler();
              }
              else {
                  timeout.setIfNotSet(invokeHandler, minimumTimeMs - elapsedTime);
              }
          }));
          return _this;
      }
      return TimeoutThrottledDomListener;
  }(lifecycle_js_1.Disposable));
  function addDisposableThrottledListener(node, type, handler, eventMerger, minimumTimeMs) {
      return new TimeoutThrottledDomListener(node, type, handler, eventMerger, minimumTimeMs);
  }
  exports.addDisposableThrottledListener = addDisposableThrottledListener;
  function getComputedStyle(el) {
      return document.defaultView.getComputedStyle(el, null);
  }
  exports.getComputedStyle = getComputedStyle;
  var SizeUtils = /** @class */ (function () {
      function SizeUtils() {
      }
      // Adapted from WinJS
      // Converts a CSS positioning string for the specified element to pixels.
      SizeUtils.convertToPixels = function (element, value) {
          return parseFloat(value) || 0;
      };
      SizeUtils.getDimension = function (element, cssPropertyName, jsPropertyName) {
          var computedStyle = getComputedStyle(element);
          var value = '0';
          if (computedStyle) {
              if (computedStyle.getPropertyValue) {
                  value = computedStyle.getPropertyValue(cssPropertyName);
              }
              else {
                  // IE8
                  value = computedStyle.getAttribute(jsPropertyName);
              }
          }
          return SizeUtils.convertToPixels(element, value);
      };
      SizeUtils.getBorderLeftWidth = function (element) {
          return SizeUtils.getDimension(element, 'border-left-width', 'borderLeftWidth');
      };
      SizeUtils.getBorderRightWidth = function (element) {
          return SizeUtils.getDimension(element, 'border-right-width', 'borderRightWidth');
      };
      SizeUtils.getBorderTopWidth = function (element) {
          return SizeUtils.getDimension(element, 'border-top-width', 'borderTopWidth');
      };
      SizeUtils.getBorderBottomWidth = function (element) {
          return SizeUtils.getDimension(element, 'border-bottom-width', 'borderBottomWidth');
      };
      SizeUtils.getPaddingLeft = function (element) {
          return SizeUtils.getDimension(element, 'padding-left', 'paddingLeft');
      };
      SizeUtils.getPaddingRight = function (element) {
          return SizeUtils.getDimension(element, 'padding-right', 'paddingRight');
      };
      SizeUtils.getPaddingTop = function (element) {
          return SizeUtils.getDimension(element, 'padding-top', 'paddingTop');
      };
      SizeUtils.getPaddingBottom = function (element) {
          return SizeUtils.getDimension(element, 'padding-bottom', 'paddingBottom');
      };
      SizeUtils.getMarginLeft = function (element) {
          return SizeUtils.getDimension(element, 'margin-left', 'marginLeft');
      };
      SizeUtils.getMarginTop = function (element) {
          return SizeUtils.getDimension(element, 'margin-top', 'marginTop');
      };
      SizeUtils.getMarginRight = function (element) {
          return SizeUtils.getDimension(element, 'margin-right', 'marginRight');
      };
      SizeUtils.getMarginBottom = function (element) {
          return SizeUtils.getDimension(element, 'margin-bottom', 'marginBottom');
      };
      return SizeUtils;
  }());
  // ----------------------------------------------------------------------------------------
  // Position & Dimension
  var Dimension = /** @class */ (function () {
      function Dimension(width, height) {
          this.width = width;
          this.height = height;
      }
      return Dimension;
  }());
  exports.Dimension = Dimension;
  function getTopLeftOffset(element) {
      // Adapted from WinJS.Utilities.getPosition
      // and added borders to the mix
      var offsetParent = element.offsetParent, top = element.offsetTop, left = element.offsetLeft;
      while ((element = element.parentNode) !== null && element !== document.body && element !== document.documentElement) {
          top -= element.scrollTop;
          var c = getComputedStyle(element);
          if (c) {
              left -= c.direction !== 'rtl' ? element.scrollLeft : -element.scrollLeft;
          }
          if (element === offsetParent) {
              left += SizeUtils.getBorderLeftWidth(element);
              top += SizeUtils.getBorderTopWidth(element);
              top += element.offsetTop;
              left += element.offsetLeft;
              offsetParent = element.offsetParent;
          }
      }
      return {
          left: left,
          top: top
      };
  }
  exports.getTopLeftOffset = getTopLeftOffset;
  /**
   * Returns the position of a dom node relative to the entire page.
   */
  function getDomNodePagePosition(domNode) {
      var bb = domNode.getBoundingClientRect();
      return {
          left: bb.left + exports.StandardWindow.scrollX,
          top: bb.top + exports.StandardWindow.scrollY,
          width: bb.width,
          height: bb.height
      };
  }
  exports.getDomNodePagePosition = getDomNodePagePosition;
  exports.StandardWindow = new /** @class */ (function () {
      function class_3() {
      }
      Object.defineProperty(class_3.prototype, "scrollX", {
          get: function () {
              if (typeof window.scrollX === 'number') {
                  // modern browsers
                  return window.scrollX;
              }
              else {
                  return document.body.scrollLeft + document.documentElement.scrollLeft;
              }
          },
          enumerable: true,
          configurable: true
      });
      Object.defineProperty(class_3.prototype, "scrollY", {
          get: function () {
              if (typeof window.scrollY === 'number') {
                  // modern browsers
                  return window.scrollY;
              }
              else {
                  return document.body.scrollTop + document.documentElement.scrollTop;
              }
          },
          enumerable: true,
          configurable: true
      });
      return class_3;
  }());
  // Adapted from WinJS
  // Gets the width of the element, including margins.
  function getTotalWidth(element) {
      var margin = SizeUtils.getMarginLeft(element) + SizeUtils.getMarginRight(element);
      return element.offsetWidth + margin;
  }
  exports.getTotalWidth = getTotalWidth;
  function getContentWidth(element) {
      var border = SizeUtils.getBorderLeftWidth(element) + SizeUtils.getBorderRightWidth(element);
      var padding = SizeUtils.getPaddingLeft(element) + SizeUtils.getPaddingRight(element);
      return element.offsetWidth - border - padding;
  }
  exports.getContentWidth = getContentWidth;
  // Adapted from WinJS
  // Gets the height of the content of the specified element. The content height does not include borders or padding.
  function getContentHeight(element) {
      var border = SizeUtils.getBorderTopWidth(element) + SizeUtils.getBorderBottomWidth(element);
      var padding = SizeUtils.getPaddingTop(element) + SizeUtils.getPaddingBottom(element);
      return element.offsetHeight - border - padding;
  }
  exports.getContentHeight = getContentHeight;
  // Adapted from WinJS
  // Gets the height of the element, including its margins.
  function getTotalHeight(element) {
      var margin = SizeUtils.getMarginTop(element) + SizeUtils.getMarginBottom(element);
      return element.offsetHeight + margin;
  }
  exports.getTotalHeight = getTotalHeight;
  // ----------------------------------------------------------------------------------------
  function isAncestor(testChild, testAncestor) {
      while (testChild) {
          if (testChild === testAncestor) {
              return true;
          }
          testChild = testChild.parentNode;
      }
      return false;
  }
  exports.isAncestor = isAncestor;
  function findParentWithClass(node, clazz, stopAtClazzOrNode) {
      while (node) {
          if (exports.hasClass(node, clazz)) {
              return node;
          }
          if (stopAtClazzOrNode) {
              if (typeof stopAtClazzOrNode === 'string') {
                  if (exports.hasClass(node, stopAtClazzOrNode)) {
                      return null;
                  }
              }
              else {
                  if (node === stopAtClazzOrNode) {
                      return null;
                  }
              }
          }
          node = node.parentNode;
      }
      return null;
  }
  exports.findParentWithClass = findParentWithClass;
  function createStyleSheet(container) {
      if (container === void 0) {
          container = document.getElementsByTagName('head')[0];
      }
      var style = document.createElement('style');
      style.type = 'text/css';
      style.media = 'screen';
      container.appendChild(style);
      return style;
  }
  exports.createStyleSheet = createStyleSheet;
  var _sharedStyleSheet = null;
  function getSharedStyleSheet() {
      if (!_sharedStyleSheet) {
          _sharedStyleSheet = createStyleSheet();
      }
      return _sharedStyleSheet;
  }
  function getDynamicStyleSheetRules(style) {
      if (style && style.sheet && style.sheet.rules) {
          // Chrome, IE
          return style.sheet.rules;
      }
      if (style && style.sheet && style.sheet.cssRules) {
          // FF
          return style.sheet.cssRules;
      }
      return [];
  }
  function createCSSRule(selector, cssText, style) {
      if (style === void 0) {
          style = getSharedStyleSheet();
      }
      if (!style || !cssText) {
          return;
      }
      style.sheet.insertRule(selector + '{' + cssText + '}', 0);
  }
  exports.createCSSRule = createCSSRule;
  function removeCSSRulesContainingSelector(ruleName, style) {
      if (style === void 0) {
          style = getSharedStyleSheet();
      }
      if (!style) {
          return;
      }
      var rules = getDynamicStyleSheetRules(style);
      var toDelete = [];
      for (var i = 0; i < rules.length; i++) {
          var rule = rules[i];
          if (rule.selectorText.indexOf(ruleName) !== -1) {
              toDelete.push(i);
          }
      }
      for (var i = toDelete.length - 1; i >= 0; i--) {
          style.sheet.deleteRule(toDelete[i]);
      }
  }
  exports.removeCSSRulesContainingSelector = removeCSSRulesContainingSelector;
  function isHTMLElement(o) {
      if (typeof HTMLElement === 'object') {
          return o instanceof HTMLElement;
      }
      return o && typeof o === 'object' && o.nodeType === 1 && typeof o.nodeName === 'string';
  }
  exports.isHTMLElement = isHTMLElement;
  exports.EventType = {
      // Mouse
      CLICK: 'click',
      DBLCLICK: 'dblclick',
      MOUSE_UP: 'mouseup',
      MOUSE_DOWN: 'mousedown',
      MOUSE_OVER: 'mouseover',
      MOUSE_MOVE: 'mousemove',
      MOUSE_OUT: 'mouseout',
      MOUSE_ENTER: 'mouseenter',
      MOUSE_LEAVE: 'mouseleave',
      CONTEXT_MENU: 'contextmenu',
      WHEEL: 'wheel',
      // Keyboard
      KEY_DOWN: 'keydown',
      KEY_PRESS: 'keypress',
      KEY_UP: 'keyup',
      // HTML Document
      LOAD: 'load',
      UNLOAD: 'unload',
      ABORT: 'abort',
      ERROR: 'error',
      RESIZE: 'resize',
      SCROLL: 'scroll',
      // Form
      SELECT: 'select',
      CHANGE: 'change',
      SUBMIT: 'submit',
      RESET: 'reset',
      FOCUS: 'focus',
      FOCUS_IN: 'focusin',
      FOCUS_OUT: 'focusout',
      BLUR: 'blur',
      INPUT: 'input',
      // Local Storage
      STORAGE: 'storage',
      // Drag
      DRAG_START: 'dragstart',
      DRAG: 'drag',
      DRAG_ENTER: 'dragenter',
      DRAG_LEAVE: 'dragleave',
      DRAG_OVER: 'dragover',
      DROP: 'drop',
      DRAG_END: 'dragend',
      // Animation
      ANIMATION_START: browser.isWebKit ? 'webkitAnimationStart' : 'animationstart',
      ANIMATION_END: browser.isWebKit ? 'webkitAnimationEnd' : 'animationend',
      ANIMATION_ITERATION: browser.isWebKit ? 'webkitAnimationIteration' : 'animationiteration'
  };
  exports.EventHelper = {
      stop: function (e, cancelBubble) {
          if (e.preventDefault) {
              e.preventDefault();
          }
          else {
              // IE8
              e.returnValue = false;
          }
          if (cancelBubble) {
              if (e.stopPropagation) {
                  e.stopPropagation();
              }
              else {
                  // IE8
                  e.cancelBubble = true;
              }
          }
      }
  };
  function saveParentsScrollTop(node) {
      var r = [];
      for (var i = 0; node && node.nodeType === node.ELEMENT_NODE; i++) {
          r[i] = node.scrollTop;
          node = node.parentNode;
      }
      return r;
  }
  exports.saveParentsScrollTop = saveParentsScrollTop;
  function restoreParentsScrollTop(node, state) {
      for (var i = 0; node && node.nodeType === node.ELEMENT_NODE; i++) {
          if (node.scrollTop !== state[i]) {
              node.scrollTop = state[i];
          }
          node = node.parentNode;
      }
  }
  exports.restoreParentsScrollTop = restoreParentsScrollTop;
  var FocusTracker = /** @class */ (function () {
      function FocusTracker(element) {
          var _this = this;
          this._onDidFocus = new event_js_2.Emitter();
          this.onDidFocus = this._onDidFocus.event;
          this._onDidBlur = new event_js_2.Emitter();
          this.onDidBlur = this._onDidBlur.event;
          this.disposables = [];
          var hasFocus = isAncestor(document.activeElement, element);
          var loosingFocus = false;
          var onFocus = function () {
              loosingFocus = false;
              if (!hasFocus) {
                  hasFocus = true;
                  _this._onDidFocus.fire();
              }
          };
          var onBlur = function () {
              if (hasFocus) {
                  loosingFocus = true;
                  window.setTimeout(function () {
                      if (loosingFocus) {
                          loosingFocus = false;
                          hasFocus = false;
                          _this._onDidBlur.fire();
                      }
                  }, 0);
              }
          };
          event_js_1.domEvent(element, exports.EventType.FOCUS, true)(onFocus, null, this.disposables);
          event_js_1.domEvent(element, exports.EventType.BLUR, true)(onBlur, null, this.disposables);
      }
      FocusTracker.prototype.dispose = function () {
          this.disposables = lifecycle_js_1.dispose(this.disposables);
          this._onDidFocus.dispose();
          this._onDidBlur.dispose();
      };
      return FocusTracker;
  }());
  function trackFocus(element) {
      return new FocusTracker(element);
  }
  exports.trackFocus = trackFocus;
  function append(parent) {
      var children = [];
      for (var _i = 1; _i < arguments.length; _i++) {
          children[_i - 1] = arguments[_i];
      }
      children.forEach(function (child) { return parent.appendChild(child); });
      return children[children.length - 1];
  }
  exports.append = append;
  var SELECTOR_REGEX = /([\w\-]+)?(#([\w\-]+))?((.([\w\-]+))*)/;
  function $(description, attrs) {
      var children = [];
      for (var _i = 2; _i < arguments.length; _i++) {
          children[_i - 2] = arguments[_i];
      }
      var match = SELECTOR_REGEX.exec(description);
      if (!match) {
          throw new Error('Bad use of emmet');
      }
      var result = document.createElement(match[1] || 'div');
      if (match[3]) {
          result.id = match[3];
      }
      if (match[4]) {
          result.className = match[4].replace(/\./g, ' ').trim();
      }
      attrs = attrs || {};
      Object.keys(attrs).forEach(function (name) {
          var value = attrs[name];
          if (/^on\w+$/.test(name)) {
              result[name] = value;
          }
          else if (name === 'selected') {
              if (value) {
                  result.setAttribute(name, 'true');
              }
          }
          else {
              result.setAttribute(name, value);
          }
      });
      arrays_js_1.coalesce(children)
          .forEach(function (child) {
          if (child instanceof Node) {
              result.appendChild(child);
          }
          else {
              result.appendChild(document.createTextNode(child));
          }
      });
      return result;
  }
  exports.$ = $;
  function show() {
      var elements = [];
      for (var _i = 0; _i < arguments.length; _i++) {
          elements[_i] = arguments[_i];
      }
      for (var _a = 0, elements_1 = elements; _a < elements_1.length; _a++) {
          var element = elements_1[_a];
          element.style.display = '';
          element.removeAttribute('aria-hidden');
      }
  }
  exports.show = show;
  function hide() {
      var elements = [];
      for (var _i = 0; _i < arguments.length; _i++) {
          elements[_i] = arguments[_i];
      }
      for (var _a = 0, elements_2 = elements; _a < elements_2.length; _a++) {
          var element = elements_2[_a];
          element.style.display = 'none';
          element.setAttribute('aria-hidden', 'true');
      }
  }
  exports.hide = hide;
  function findParentWithAttribute(node, attribute) {
      while (node) {
          if (node instanceof HTMLElement && node.hasAttribute(attribute)) {
              return node;
          }
          node = node.parentNode;
      }
      return null;
  }
  function removeTabIndexAndUpdateFocus(node) {
      if (!node || !node.hasAttribute('tabIndex')) {
          return;
      }
      // If we are the currently focused element and tabIndex is removed,
      // standard DOM behavior is to move focus to the <body> element. We
      // typically never want that, rather put focus to the closest element
      // in the hierarchy of the parent DOM nodes.
      if (document.activeElement === node) {
          var parentFocusable = findParentWithAttribute(node.parentElement, 'tabIndex');
          if (parentFocusable) {
              parentFocusable.focus();
          }
      }
      node.removeAttribute('tabindex');
  }
  exports.removeTabIndexAndUpdateFocus = removeTabIndexAndUpdateFocus;
  function getElementsByTagName(tag) {
      return Array.prototype.slice.call(document.getElementsByTagName(tag), 0);
  }
  exports.getElementsByTagName = getElementsByTagName;
  /**
   * Find a value usable for a dom node size such that the likelihood that it would be
   * displayed with constant screen pixels size is as high as possible.
   *
   * e.g. We would desire for the cursors to be 2px (CSS px) wide. Under a devicePixelRatio
   * of 1.25, the cursor will be 2.5 screen pixels wide. Depending on how the dom node aligns/"snaps"
   * with the screen pixels, it will sometimes be rendered with 2 screen pixels, and sometimes with 3 screen pixels.
   */
  function computeScreenAwareSize(cssPx) {
      var screenPx = window.devicePixelRatio * cssPx;
      return Math.max(1, Math.floor(screenPx)) / window.devicePixelRatio;
  }
  exports.computeScreenAwareSize = computeScreenAwareSize;
  /**
   * See https://github.com/Microsoft/monaco-editor/issues/601
   * To protect against malicious code in the linked site, particularly phishing attempts,
   * the window.opener should be set to null to prevent the linked site from having access
   * to change the location of the current page.
   * See https://mathiasbynens.github.io/rel-noopener/
   */
  function windowOpenNoOpener(url) {
      if (platform.isNative || browser.isEdgeWebView) {
          // In VSCode, window.open() always returns null...
          // The same is true for a WebView (see https://github.com/Microsoft/monaco-editor/issues/628)
          window.open(url);
      }
      else {
          var newTab = window.open();
          if (newTab) {
              newTab.opener = null;
              newTab.location.href = url;
          }
      }
  }
  exports.windowOpenNoOpener = windowOpenNoOpener;
  function animate(fn) {
      var step = function () {
          fn();
          stepDisposable = exports.scheduleAtNextAnimationFrame(step);
      };
      var stepDisposable = exports.scheduleAtNextAnimationFrame(step);
      return lifecycle_js_1.toDisposable(function () { return stepDisposable.dispose(); });
  }
  exports.animate = animate;
  

});
