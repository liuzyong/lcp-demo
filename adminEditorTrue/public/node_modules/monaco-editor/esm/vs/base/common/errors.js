define('node_modules/monaco-editor/esm/vs/base/common/errors', function(require, exports, module) {

  "use strict";
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.illegalState = exports.illegalArgument = exports.canceled = exports.isPromiseCanceledError = exports.transformErrorForSerialization = exports.onUnexpectedExternalError = exports.onUnexpectedError = exports.errorHandler = exports.ErrorHandler = void 0;
  /*---------------------------------------------------------------------------------------------
   *  Copyright (c) Microsoft Corporation. All rights reserved.
   *  Licensed under the MIT License. See License.txt in the project root for license information.
   *--------------------------------------------------------------------------------------------*/
  // Avoid circular dependency on EventEmitter by implementing a subset of the interface.
  var ErrorHandler = /** @class */ (function () {
      function ErrorHandler() {
          this.listeners = [];
          this.unexpectedErrorHandler = function (e) {
              setTimeout(function () {
                  if (e.stack) {
                      throw new Error(e.message + '\n\n' + e.stack);
                  }
                  throw e;
              }, 0);
          };
      }
      ErrorHandler.prototype.emit = function (e) {
          this.listeners.forEach(function (listener) {
              listener(e);
          });
      };
      ErrorHandler.prototype.onUnexpectedError = function (e) {
          this.unexpectedErrorHandler(e);
          this.emit(e);
      };
      // For external errors, we don't want the listeners to be called
      ErrorHandler.prototype.onUnexpectedExternalError = function (e) {
          this.unexpectedErrorHandler(e);
      };
      return ErrorHandler;
  }());
  exports.ErrorHandler = ErrorHandler;
  exports.errorHandler = new ErrorHandler();
  function onUnexpectedError(e) {
      // ignore errors from cancelled promises
      if (!isPromiseCanceledError(e)) {
          exports.errorHandler.onUnexpectedError(e);
      }
      return undefined;
  }
  exports.onUnexpectedError = onUnexpectedError;
  function onUnexpectedExternalError(e) {
      // ignore errors from cancelled promises
      if (!isPromiseCanceledError(e)) {
          exports.errorHandler.onUnexpectedExternalError(e);
      }
      return undefined;
  }
  exports.onUnexpectedExternalError = onUnexpectedExternalError;
  function transformErrorForSerialization(error) {
      if (error instanceof Error) {
          var name_1 = error.name, message = error.message;
          var stack = error.stacktrace || error.stack;
          return {
              $isError: true,
              name: name_1,
              message: message,
              stack: stack
          };
      }
      // return as is
      return error;
  }
  exports.transformErrorForSerialization = transformErrorForSerialization;
  var canceledName = 'Canceled';
  /**
   * Checks if the given error is a promise in canceled state
   */
  function isPromiseCanceledError(error) {
      return error instanceof Error && error.name === canceledName && error.message === canceledName;
  }
  exports.isPromiseCanceledError = isPromiseCanceledError;
  /**
   * Returns an error that signals cancellation.
   */
  function canceled() {
      var error = new Error(canceledName);
      error.name = error.message;
      return error;
  }
  exports.canceled = canceled;
  function illegalArgument(name) {
      if (name) {
          return new Error("Illegal argument: " + name);
      }
      else {
          return new Error('Illegal argument');
      }
  }
  exports.illegalArgument = illegalArgument;
  function illegalState(name) {
      if (name) {
          return new Error("Illegal state: " + name);
      }
      else {
          return new Error('Illegal state');
      }
  }
  exports.illegalState = illegalState;
  

});
