import React from 'react';
import PropTypes from 'prop-types';
import { Schema, RendererProps } from './types';
export declare const defaultChildrenSortList: string[];
export default class BasicEditor<T extends RendererProps = RendererProps> extends React.Component<T> {
    static contextTypes: {
        editor: PropTypes.Requireable<object>;
        editorNode: PropTypes.Requireable<object>;
    };
    static childContextTypes: {
        editorNode: PropTypes.Requireable<object>;
    };
    ref: any;
    renderer: any;
    tipName: string;
    Renderer: React.ReactType;
    static propsList: Array<string>;
    static displayName: string;
    highlight: any;
    regions: any;
    movable?: boolean;
    regionDefaultNodes: Partial<T>;
    toolbarBtns: Array<{
        visible?: boolean;
        icon: string;
        tooltip?: string;
        id: string;
        placement?: string;
        test?: (props: any, editor: any) => any;
    }>;
    toolbarDom: React.RefObject<HTMLDivElement>;
    containers: Array<string>;
    removable: boolean;
    replaceable: boolean;
    codeEditable: boolean;
    duplicatable: boolean;
    draggable: boolean;
    dropable: boolean;
    $schema: string;
    settingsSchema: any;
    clickIgnoreSelecor: string;
    nodes: Array<any>;
    placeholder: string;
    mounted: boolean;
    replaceSettings: boolean;
    regions2path: any;
    childrenSortList: {
        [propName: string]: Array<string>;
    };
    syncOutlineLazy: any;
    constructor(props: T);
    getChildContext(this: any): {
        editorNode: {
            id: any;
            add: any;
            remove: any;
            getNodes: any;
            component: any;
            parent: any;
        };
    };
    componentWillMount(): void;
    componentDidMount(): void;
    componentDidUpdate(): void;
    componentWillUnmount(): void;
    /**
     * 用来判断当前编辑器节点具备什么操作能力。
     * 直接调用 toolbar 里面的 test 方法。
     * @param type string
     */
    can(type: string): boolean;
    /**
     * 返回 dom 元素。
     */
    getElement(): HTMLElement | null;
    /**
     * 最外层的 Editor 会调用，一遍用来切换选中状态。
     * @param activeId
     * @param prevId
     * @param mode
     */
    editorWillUpdate(activeId: string | null, prevId: string | null, mode: string): any;
    patchSchema(): void;
    childRef(ref: any): void;
    highlightRef(ref: any): void;
    updateHighlight(viewOnly?: boolean): void;
    getWrappedInstance(): any;
    getTarget(): HTMLElement;
    addNode(node: any): void;
    removeTo(node: any): void;
    getNodes(): any[];
    syncOutline(): void;
    handleClick(e: Event): void;
    handleToolbarBtnClick(e: React.MouseEvent<any>): void;
    handleToolbarAction(id: string): void;
    handleToolbarDragStart(e: any): void;
    /**
     * 选中父级编辑器节点。
     */
    selectParent(): void;
    /**
     * 向外选中
     */
    selectOutside(): void;
    /**
     * 向内选中
     */
    selectInside(): void;
    /**
     * 激活当前编辑器节点。
     * @param forceOpen
     */
    active(forceOpen?: boolean): void;
    /**
     * 起到 deActive 的作用，取消选中。
     */
    closeSetting(): void;
    /**
     * 复制一份自己。
     */
    duplicateSelf(): void;
    /**
     * 点开当前节点的编辑面板。
     */
    openEditForm(forceOpen?: boolean): void;
    /**
     * 点开当前节点的代码面板。
     */
    openEditCode(): void;
    /**
     * 删除自己
     */
    deleteSelf(): void;
    /**
     * 剪切掉自己
     */
    cutSelf(): void;
    /**
     * 把自己往上移动
     */
    moveUp(): void;
    /**
     * 把自己往下移动
     */
    moveDown(): void;
    /**
     * 向上选中节点
     */
    selectBackward(): boolean;
    /**
     * 向下选中节点
     */
    selectForward(): boolean;
    /**
     * 获取当前节点的配置项。
     */
    getSettingsValue(): any;
    /**
     * 设置当前节点的配置项。
     */
    setSettingsValue(value: any, mode?: string, callback?: (data: any) => void): void;
    attachAddBtn(container: any, btn: any, defaultValue?: any): any;
    normalizeContainer(schema: any, containers: Array<string>): any;
    onAddNode(region: string, child: any): any;
    /**
     * 给当前节点添加成员。
     * @param key
     * @param child
     * @param updateSettings
     */
    addChild(key: string, child: any): void;
    /**
     * 清空容器里面的所有节点。
     * @param key
     */
    emptyChild(key: string): void;
    /**
     * 选择一个选择渲染器的框，并进行添加。
     * @param region
     * @param key
     * @param cb
     * @param whiteList
     * @param updateSettings
     * @param sortList
     */
    pickChild(region: string, key?: string, cb?: (child: any, id: string, editor: any) => void, whiteList?: Array<string> | ((type: string) => boolean), updateSettings?: boolean, sortList?: Array<string>): void;
    /**
     * 询问当前节点知否能接收指定节点作为孩子。
     * @param type
     * @param region
     * @param whiteList
     * @param mode
     */
    acceptChild(type: string, region: string, rendererId?: string): boolean | null;
    /**
     * 把自己替换成别的渲染器。交互是弹出个框让用户选择，然后替换。
     */
    changeSelf(): void;
    /**
     * 用来生成右键功能菜单列表。
     */
    getContextMenus(): Array<any>;
    updateRegion(name?: string): void;
    regionRef(regionName: string, ref: any): void;
    renderChild(region: string, node: Schema, props: any): JSX.Element;
    renderRenderer(props?: any): JSX.Element;
    renderPlaceholder(props?: any): JSX.Element;
    renderTip(): JSX.Element;
    renderToolbars(): JSX.Element;
    renderSecondaryToolbars(): React.ReactNode;
    renderButton(handler: (e: React.MouseEvent<HTMLButtonElement>) => void, tooltip?: string, icon?: string, props?: any): JSX.Element;
    renderBasic(enabled?: boolean): JSX.Element | JSX.Element[];
    render(): JSX.Element;
}
